// 1-st variant
#include <iostream> 
using namespace std;

int checkSymbolsPositive(int* n, char* st)   // функция проверки. Ввели положительное число или нет.
{
    int f = 0;
    for (int i = 0; i < strlen(st); i++)
    {
        if (st[i] < '0' || st[i] > '9')
        {
            cout << "you have entered incorrect symbol" << endl;
            return 401;
        }
        f *= 10;
        f += st[i] - '0';
    }
    *n = f;
    if ((*n) == 0)
    {
        cout << "You enterted 0. Error." << endl;
        return 401;
    }
    delete[] st;
    return 0;
}

int enterNumber(int* n)     // функция ввода числа для проверки
{
    char* st = new char[1000];   // массив только для проверки
    cout << "Enter a number: ";
    cin >> st;
    if (checkSymbolsPositive(n, st) != 0)
    {
        cout << "You needn't to enter symbols or 0. Only int values." << endl;
        return 400;
    }
    else
    {
        return 0;
    }
}

int sumNum(int a, int b)
{
	int sum = a ^ b, keep = (a & b) << 1;	// с помощью xor можно найти сумму двух чисел, но если происходит переход в следующий разряд, когда 1 + 1 = 0 и в след. разряд 1, то просто xor не достаточно

	while (keep)	// пока при xor будет в каком-то разряде 1+1(т.е. будет теряться 1, переходящая в след разряд), то rank будет не 0 и хранить потерянные 1. Как только при xor не будет 1 + 1 в каком либо разряде(и, соответсвенно, сумма будет верная), то при xor будет верная сумма, т.к. не будут теряться единички
	{
		int temp = sum;					// ранг каждый раз для предыдущей суммы
		sum ^= keep;					// возвращаем в запись sum потерянные единицы, если зашли в цикл, то значит потерянные единицы есть. После этого в следующей строке проверяем, было ли 1 + 1 при этом xor и соответсвенно были ли потерянные 1
		keep = (temp & keep) << 1;		// с помощью keep, т.к. если при xor единицы, переходящие в следующий разряд теряются, то нужно прибавить их в запись sum на следующей итерации, чтобы не было потерь. Т.е. после каждом прибавлении потерянных единиц нужно проверять, не теряются ли снова
	}

	return sum;
}

int sub(int a, int b)
{
	b = sumNum(~b, 1);     // для того, чтобы получить противоположное число, нужно инвертировать все биты данного числа. Инвертирут даже нули, который стоят в левой части двоичной записи числа. 
						   // Например, 5 - это 101 в двоичной, но оно является четырёхбитным и поэтому инвертироваться будет 4 цифры, а не 3.
						   // И чтобы получилось противоположное, нужно после инвертирования просто прибавить 1. Вычисления компьютер проводит в дополнительном коде, поэтому нужно перевести число в дополнительный код таким вот способом.
						   // т.к. для положительных чисел прямой и дополнительный код совпадают, то можно в других вычислениях использовать прямой код. Обычные онлайн калькуляторы для перевода числа из двоичной системы в десятичную работают с прямым.
	return(sumNum(a, b));
}

int multiply(int a, int b)
{
	int res = 0;

	while (b)
	{
		if (b & 1)	// если самый правый бит в делителе это 1, то прибавляем к результату делимое с текущим сдвигом. Если 0, то просто пропуск, т.к. нули нет смысла прибавлять.
		{
			res = sumNum(res, a);
		}

		a <<= 1;	// после каждого прибавления делимого, с текущим сдвигом, или нулей, нужно сдвинуть делимое, которое, если самый правый бит в делителе равен 1, будет сдвинуто на 1 влево(всё видно по столбику умножения)
		b >>= 1;	// сложили и нужно в следующей итерации проверять следующий бит в делителе. Если такого нету(когда всё b стало равно 0), то больше не нужно прибавлять делимое или делитель
		// Всё видно по умножению, записанному в столбик
	}

	return res;
}

int divide(int a, int b)
{
	int times = 0;
	bool check = true;
	if (a < b)		// чтобы отсеить ситуацию, когда первоначально a меньше b.
	{
		check = false;
	}

	while (a > 0 && check)	// вычитаем и считаем, сколько раз вместился делитель в число(ищем целую часть при делении). Если равен 0, то остановка (тогда a будет делиться нацело на b, но для этой функции это не имеет значения), и если a < 0, то остановка(тогда a не будет нацело делиться на b, но для этой функции это не имеет значения) 
	{
		a = sub(a, b);
		times = sumNum(times, 1);		// каждый раз увеличивается счётчик, который показывает, сколько раз целый делитель содержится в делимом. 
										// Можно к двоичному коду прибавлять 1, чтобы получить следующее число, что равноценно times++, т.к. каждое следующее число, это увеличенный на 1 двоичный код предыдущего
	}
	return times;
}

int mod(int a, int b)
{
	return a - multiply(divide(a, b), b);		// обычный принцип работы mod. Из числа вычитается делитель умноженный на целую часть(к примеру 5/2 = 2) от такого деления
}

int main()
{
	cout << "A program that checks if an entered number is divisible by given primes." << endl;
	cout << "The program does not contain multiplication, division, subtraction(including the operation of taking the remainder of a division)." << endl;
	cout << "Bitwise operations are used." << endl;
	int n, q;	// q просто для проверки. Можно было, впринципе, и пропускать отрицательные числа. Просто из 0 вычитать отрицательное и получалось бы положительное и тогда вычисления по-прежнему проводились бы с положительным.
	do
	{
		q = enterNumber(&n);	// проверка на ввод
	} while (q != 0);
	int input[] = { 3, 37, 89 };	// делители для числа n. Даны по условию.
	bool check = true;

	for (int i = 0; (i < 3) && check; i++)
	{
		if (mod(n, input[i]) != 0)
		{
			check = false;		// если хотя бы одно число не подходит, то нужно присвоить false, чтобы после цикла осуществить вывод, согласно результату
			break;				// и можно не смотреть дальше
		}
	}

	if (check)
	{
		cout << "Yes, it is divided.";
	}
	else
	{
		cout << "No";
	}
}