#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

int main()
{
	cout << "The program finds the n-th bindecimal number (whose binary representation suffix matches its decimal notation)." << endl;
	int n;	// n-е двудесятичное число
	cout << "Enter a number of which in a row you want to find a bindecimal number: " << endl;
	cin >> n;
	if (n <= 0 || n >= 10000)
	{
		cout << "Incorrect enter." << endl;
		return 0;
	}
	vector<unsigned long long int> a (1, 0);		// первоначально при k = 1 в a 0
	vector<unsigned long long int> b (1, 1);		// первоначально при k = 1 в b 1

	// основывается на том, что создаётся вспомогательное множество A(k+1), в котором хранятся числа из предыдущего множества A (k) и B (k), у которых в (k)-м бите находится 0. B - это множество, в котором хранятся двудесятичные числа, которые и считаем.
	// если текущее множество B (k) для k-й строчки, если сделать таблицу, перебирали и не дошли до n-го элемента(по счёту), то нужно создать сразу A (k+1), а потом из A(k+1) получить новое множество B(k+1) прибавив к каждому элементу множества A 10 в степени k.
	// k показывает, сколько цифр совпадает у десятичного числа в данной условной строке (во множествах A и B для текущего k) с цифрами справа в его двоичном представлении. В A (k) и в B(k) текущей условной строки числа меньшие, чем 10 в степени k
	// P.S. (A = a, B = b и наоборот, в комментариях)
	
	int counter = 1;
	for (int k = 1; ; k++)	// перебираем строчки таблицы, если до сих пор не нашли n-e число в b
	{
		for (int i = 0; i < b.size(); i++)	// для поиска в b, множестве двудесятичных чисел, n-го по счёту(начиная с 1, 10, 11 ...). Ищется в текущей b (k), в предыдущей итерации его создавали как (k+1)
		{
			if (counter == n)
			{
				cout << "Result: " << b.at(i) << endl;
				return 0;
			}
			counter++;

		}
		vector<unsigned long long int> buffer;	// т.к. мы ещё не знаем, что будет находиться в новом векторе a, то нужно скопировать вектор a в буфер и работать с буфером, постепенно заполняя чистое a
		buffer = a;
		a.clear();
		for (int i = 0; i < buffer.size(); i++)	// Перебираем текущую строчку (k), чтобы заполнить (k+1), т.к. в этой не нашли нужное n-e число
		{
			// нужно записать в A (k+1) (это следующая строчка k+1) все элементы из A (k) и B (k), но только те, у которых k-й бит был равен 0, т.е. нужно сдвинуть на k - 1 битов вправо и проверить самый первый справа
			int save = buffer.at(i);
			save >>= k;
			if (!(save & 1))	// проверяем, k-й бит 0 или нет. Если 0, то выписываем число в A (k+1) из которого далее получим B (k+1), которое проверится в следующей итерации внешнего цикла
			{
				a.push_back(buffer.at(i));
			}
		}
		for (int i = 0; i < b.size(); i++)		// нужно перебрать b (k) по такому же принципу, как и a (k). И позаписывать подходящии числа в конец a (k+1)
		{
			int save = b.at(i);
			save >>= k;
			if (!(save & 1))	// проверяем, k-й бит 0 или нет. Если 0, то выписываем число в A (k+1) из которого далее получим B (k+1), которое проверится в следующей итерации внешнего цикла
			{
				a.push_back(b.at(i));
			}
		}
		// теперь нужно создать новое B для строчки (k+1), которое проверится в следующей итерации внешнего цикла. Оно создаётся прибавлением к элементам A (k+1) 10 в степени k
		b.clear();	// можно очистить вектор b (k) строчки (k), т.к. сейчас будет создавать новый вектор, который является продолжением предыдущих, но без тех элементов, т.к. те мы уже посчитали
		for (int p = 0; p < a.size(); p++)
		{
			b.push_back(a.at(p) + (unsigned long long int)pow(10, k));
		}
	}
}